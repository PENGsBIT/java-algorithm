package 矩阵;

//逆时针螺旋数组，（0，0）点值为1，x轴向右为正，y轴向下为正
//        ___x__
//       |y
//      |
//
//      21  22 .......
//      20  7  8 9  10
//      19  6  1 2  11
//      18  5  4 3  12
//      17 16 15 14 13
//设1点的坐标是(0,0)，x方向向右为正，y方向向下为正。例如：7的坐标为(-1,-1)，2的坐标为(0,1)，3的坐标为(1,1)。
//实现输入任意一点坐标(x,y)，输出所对应的数字；或输入任意数字，输出该数字的坐标。

public class 螺旋队列 {
    //我们从中可以观察到，这个螺旋队列是顺时针螺旋向外扩展的。我们可以把它看成一层一层向外延伸，第0层为中间的那个1，
    // 第1层为2到9，第2层为10到25，第三层为26到49。我们可以看出，每一层都有一个最大值max。
    // 例如我们就看，第0层到第3层的最大值依次为，1，9，25，49.(都在右上角)
    // 所以我们可以总结规律，确定它所在的层数，以及它在这一层的哪条边上（分为上、右、下、左四条边）。
    // 设层数为c，则max=(2*c+1)^2;而c = max(|x|,|y|);
    //我们的下一步工作就是分别找上下左右四条边上的值与max的对应关系：
    //上边：Utop = max+(x+y);
    //左边： Uleft= max+(3*x-y);
    //下边：Ubottom = max + (-x - 5*y);
    //右边：Uright = max+(-7*x+y);

    //输入坐标，输出对应的数字

    public static int Spiral_Queue(int x, int y) {
        int c = Math.max(Math.abs(x), Math.abs(y));// 该坐标所在第几层
        int max = (int) Math.pow(2 * c + 1, 2); //该层的最大值

        if (y == -c) //上
            //|y|>=|x|y<0,max+y实际就是（0，-c）点在这个地方计算x的偏移量
            return max + y + x;
        else if (x == -c) //左
            //x>=y,且数值沿着y轴反向加+1,因此为-y,max + 3 * x实际就是（-c，0）点在这个地方计算x的偏移量
            return max + (3 * x - y);
        else if (y == c) //下
            //y>=x,max-5 * y实际就是（0，-c）点在这个地方计算x的偏移量
            return max + (-x - 5 * y);
        else  //右

            return max + (-7 * x + y);

    }

    public static void main(String[] args) {
        System.out.println(Spiral_Queue(-1, -1));

    }

}
