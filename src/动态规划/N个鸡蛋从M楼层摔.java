package 动态规划;

public class N个鸡蛋从M楼层摔 {
    //有一栋楼共100层，一个鸡蛋从第N层及以上的楼层落下来会摔破，
    // 在第N层以下的楼层落下不会摔破。给你2个鸡蛋，设计方案找出N，并且保证在最坏情况下， 最小化鸡蛋下落的次数。
    //类推N个鸡蛋

    // W(n,k) ，其中 n 代表可用于测试的杯子数，k 代表被测试的楼层数。对于问题 W(2,10)， 我们可以如此考虑
    //将第 1 个杯子，在第 i 层扔下（ i 可以为 1～k 的任意值），如果碎了，则我们需要用第 2 个杯子，解决从第 1 层到第 i-1 层楼的 子问题 W(1,i-1)；
    //如果这个杯子没碎，则我们需要用这两个杯子，解决从 i+1 层到第 100 层的子问题 W(2,100-i)。
    //解决这两个问题，可以分别得到一个尝试次数 p 与 q，我们取这两个次数中的较大者(假设是 p )，将 p 与第 1 次在 i 层执行测试的这一次相加，则 p+1 就是第一次将杯子扔在 i 层来解决 W(2，100) 所需的最少测试次数，将其表示为ti。
    //对于这 100 层楼的问题，第一次，我们可以把杯子扔在 100 层中的任何一层，所以可以得到 100 中解决方案的测试次数 T{t1,t2,t3,……,t100} ，在这些结果中，我们选取最小的 ti，使得对于集合 T 中任意的值 tj(1 <= j <= 100,j != i)，都有ti <= tj，则 ti 就是这个问题的答案。
    //用公式来描述就是：
    //
    //W(n, k) = 1 + min{max(W(n -1, x -1), W(n, k - x))}, x in {2, 3, ……，k}
    //
    //其中x是第一次的测试的楼层位置
    //其中W(1,k) = k（相当于 1 个杯子测试 k 层楼问题），W(0,k) = 0，W(n, 0) = 0
    //所以在计算 W(2,100) 之前，我们需先计算出所有 W(1,0) ,……, W(1,100) , W(2,0),……,W(2,99)这些的值。
    //使用递推的方法实现，代码如下：
    public static int DroppingCups(int cups, int floors) {
        if(cups < 1 || floors < 1) return 0;

        int[][] dp = new int[cups + 1][floors + 1];
//        //零或一个鸡蛋
//        for (int i = 0; i <= floors; i++) {
//            //dp[0][i] = 0;
//            dp[1][i] = i;
//        }
//        //零或一层楼
//        for (int i = 2; i <= cups; i++) {
//            //dp[i][0] = 0;
//            dp[i][1] = 1;
//        }

        for(int i=1;i<=cups; i++){
            for(int j=1; j<=floors; j++)
                dp[i][j] = j;//初始化，最坏的步数
        }

        //最坏情况下代价最小
        for (int i = 2; i <= cups; i++) {
            for (int j = 2; j <= floors; j++) {
                for (int k = 1; k < j; k++) {
                    //这里的DP的递推公式为f[n][m] = 1+max(f[n-1][k-1],f[n][m-k]) k属于[1,m-1]
                    //从1-m层中随机抽出来一层k
                    //如果第一个鸡蛋在k层碎了，那么我们将测试1~k-1层，就可以找出来，也即1+f[1][k-1]
                    //如果第一个鸡蛋在k层没有碎，那么我们将测试k+1~m也即m-(k+1)+1=m-k层，
                    //      这里也是重点！！！！
                    //      现在我们手里有2个鸡蛋，要测试m-k层，那么我想问，此时和你手里有2个鸡蛋要测试1~m-k层有什么区别？
                    //      没有区别！是的在已知k层不碎的情况下，测试k+1~m层的方法和测试1~m-k没区别，所以可以写成 1+f[n][m-k] 其中1表示为 在k层的那一次测试
                    //max表示在k层碎掉或者没碎掉两种情况下的最多需要多少次"最坏情况"
                    //kk递增寻找在最坏情况下的代价最小
                    dp[i][j] = Math.min(dp[i][j], 1 + Math.max(dp[i - 1][k - 1], dp[i][j - k]));
                }

            }
        }

        return dp[cups][floors];
    }

    public static void main(String[] args) {
        System.out.println(DroppingCups(2, 100));

    }
}
