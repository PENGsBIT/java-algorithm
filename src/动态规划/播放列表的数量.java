package 动态规划;/**
 * @program: javatest
 * @author: zpc
 * @create: 2019-09-12 19:14
 **/

/**
 * @Author: zpc
 * @Description: leetcode920. 播放列表的数量
 * 你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：
 *
 * 每首歌至少播放一次。
 * 一首歌只有在其他 K 首歌播放完之后才能再次播放。
 * 返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。
 *
 *  
 *
 * 示例 1：
 *
 * 输入：N = 3, L = 3, K = 1
 * 输出：6
 * 解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].
 * 示例 2：
 *
 * 输入：N = 2, L = 3, K = 0
 * 输出：6
 * 解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]
 * 示例 3：
 *
 * 输入：N = 2, L = 3, K = 1
 * 输出：2
 * 解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]
 *
 * @Create: 2019-09-12 19:14
 **/


public class 播放列表的数量 {
    public static final int MOD= (int) (Math.pow(10, 9) + 7);
    //f(n,l,k)表示n首歌填充l个位置，相同歌的间隔超过k。那么，我们对于第l个位置来说只有两种情况
    //
    //之前没有相同的歌，也就是说n-1首歌填充了前面l-1个位置，即f(n-1,l-1,k)
    //之前有相同的歌，也就是说n首歌填充了前面l-1个位置，即f(n,l-1,k)
    //
    // 对于第一种情况，因为有n首歌，所以会出现n次。而对于第二种情况，由于相同的歌不能间隔k，所以会出现n-k次，那么
    //f(n,l,k)=f(n-1,l-1,k)*n+f(n,l-1,k)*(n-k)
    //接着我们考虑边界条件：当n==l时，即为全排列，也就是n!种；当i<=K的时候，解不存在，很好理解；
    // 当n==K+1时，也是全排列，因为此时最后一首歌会和第一首歌相同。
    public int numMusicPlaylists(int N, int L, int K) {
        long[][] dp = new long[L+1][N+1];
        dp[0][0] = 1;
        for (int i = 1; i <= L; i++){
            for (int j = 1; j <= N; j++){
                dp[i][j] = (dp[i-1][j-1] * (N - (j-1)))%MOD;
                if (j > K){
                    dp[i][j] = (dp[i][j] + (dp[i-1][j] * (j-K))%MOD)%MOD;
                }
            }
        }
        return (int)dp[L][N];
    }
}
